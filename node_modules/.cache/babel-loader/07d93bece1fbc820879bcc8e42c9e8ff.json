{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Hunani Trading Co\\\\react\\\\quotation\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport React, { forwardRef, useState, useRef, useMemo, useLayoutEffect, useEffect, useImperativeHandle, useCallback, createElement } from 'react';\nimport EventBus from './EventBus';\nimport InteractionMasks from './masks/InteractionMasks';\nimport HeaderRow from './HeaderRow';\nimport FilterRow from './FilterRow';\nimport Row from './Row';\nimport SummaryRow from './SummaryRow';\nimport { ValueFormatter } from './formatters';\nimport { assertIsValidKey, getColumnMetrics, getColumnScrollPosition, getHorizontalRangeToRender, getScrollbarSize, getVerticalRangeToRender, getViewportColumns } from './utils';\nimport { CellNavigationMode } from './common/enums';\n/**\r\n * Main API Component to render a data grid of rows and columns\r\n *\r\n * @example\r\n *\r\n * <DataGrid columns={columns} rows={rows} />\r\n*/\n\nfunction DataGrid(_ref, ref) {\n  var rawColumns = _ref.columns,\n      rows = _ref.rows,\n      summaryRows = _ref.summaryRows,\n      rowKey = _ref.rowKey,\n      onRowsUpdate = _ref.onRowsUpdate,\n      width = _ref.width,\n      _ref$height = _ref.height,\n      height = _ref$height === void 0 ? 350 : _ref$height,\n      _ref$minColumnWidth = _ref.minColumnWidth,\n      minColumnWidth = _ref$minColumnWidth === void 0 ? 80 : _ref$minColumnWidth,\n      _ref$rowHeight = _ref.rowHeight,\n      rowHeight = _ref$rowHeight === void 0 ? 35 : _ref$rowHeight,\n      _ref$headerRowHeight = _ref.headerRowHeight,\n      headerRowHeight = _ref$headerRowHeight === void 0 ? rowHeight : _ref$headerRowHeight,\n      _ref$headerFiltersHei = _ref.headerFiltersHeight,\n      headerFiltersHeight = _ref$headerFiltersHei === void 0 ? 45 : _ref$headerFiltersHei,\n      selectedRows = _ref.selectedRows,\n      onSelectedRowsChange = _ref.onSelectedRowsChange,\n      sortColumn = _ref.sortColumn,\n      sortDirection = _ref.sortDirection,\n      onSort = _ref.onSort,\n      filters = _ref.filters,\n      onFiltersChange = _ref.onFiltersChange,\n      _ref$defaultFormatter = _ref.defaultFormatter,\n      defaultFormatter = _ref$defaultFormatter === void 0 ? ValueFormatter : _ref$defaultFormatter,\n      _ref$rowRenderer = _ref.rowRenderer,\n      RowRenderer = _ref$rowRenderer === void 0 ? Row : _ref$rowRenderer,\n      emptyRowsRenderer = _ref.emptyRowsRenderer,\n      onRowClick = _ref.onRowClick,\n      onScroll = _ref.onScroll,\n      onColumnResize = _ref.onColumnResize,\n      onSelectedCellChange = _ref.onSelectedCellChange,\n      onCheckCellIsEditable = _ref.onCheckCellIsEditable,\n      _ref$enableFilters = _ref.enableFilters,\n      enableFilters = _ref$enableFilters === void 0 ? false : _ref$enableFilters,\n      _ref$enableCellAutoFo = _ref.enableCellAutoFocus,\n      enableCellAutoFocus = _ref$enableCellAutoFo === void 0 ? true : _ref$enableCellAutoFo,\n      _ref$enableCellCopyPa = _ref.enableCellCopyPaste,\n      enableCellCopyPaste = _ref$enableCellCopyPa === void 0 ? false : _ref$enableCellCopyPa,\n      _ref$enableCellDragAn = _ref.enableCellDragAndDrop,\n      enableCellDragAndDrop = _ref$enableCellDragAn === void 0 ? false : _ref$enableCellDragAn,\n      _ref$cellNavigationMo = _ref.cellNavigationMode,\n      cellNavigationMode = _ref$cellNavigationMo === void 0 ? CellNavigationMode.NONE : _ref$cellNavigationMo,\n      _ref$editorPortalTarg = _ref.editorPortalTarget,\n      editorPortalTarget = _ref$editorPortalTarg === void 0 ? document.body : _ref$editorPortalTarg,\n      rowClass = _ref.rowClass;\n\n  /**\r\n   * refs\r\n   * */\n  var gridRef = useRef(null);\n  var lastSelectedRowIdx = useRef(-1);\n  /**\r\n   * states\r\n   */\n\n  var _useState = useState(function () {\n    return new EventBus();\n  }),\n      _useState2 = _slicedToArray(_useState, 1),\n      eventBus = _useState2[0];\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      gridWidth = _useState4[0],\n      setGridWidth = _useState4[1];\n\n  var _useState5 = useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      scrollTop = _useState6[0],\n      setScrollTop = _useState6[1];\n\n  var _useState7 = useState(0),\n      _useState8 = _slicedToArray(_useState7, 2),\n      scrollLeft = _useState8[0],\n      setScrollLeft = _useState8[1];\n\n  var _useState9 = useState(function () {\n    return new Map();\n  }),\n      _useState10 = _slicedToArray(_useState9, 2),\n      columnWidths = _useState10[0],\n      setColumnWidths = _useState10[1];\n  /**\r\n   * computed values\r\n   */\n\n\n  var viewportWidth = (width || gridWidth) - 2; // 2 for border width;\n\n  var _useMemo = useMemo(function () {\n    return getColumnMetrics({\n      columns: rawColumns,\n      minColumnWidth: minColumnWidth,\n      viewportWidth: viewportWidth,\n      columnWidths: columnWidths,\n      defaultFormatter: defaultFormatter\n    });\n  }, [columnWidths, rawColumns, defaultFormatter, minColumnWidth, viewportWidth]),\n      columns = _useMemo.columns,\n      lastFrozenColumnIndex = _useMemo.lastFrozenColumnIndex,\n      totalColumnWidth = _useMemo.totalColumnWidth;\n\n  var _useMemo2 = useMemo(function () {\n    return getHorizontalRangeToRender(columns, lastFrozenColumnIndex, viewportWidth, scrollLeft);\n  }, [scrollLeft, columns, lastFrozenColumnIndex, viewportWidth]),\n      _useMemo3 = _slicedToArray(_useMemo2, 2),\n      colOverscanStartIdx = _useMemo3[0],\n      colOverscanEndIdx = _useMemo3[1];\n\n  var viewportColumns = useMemo(function () {\n    return getViewportColumns(columns, colOverscanStartIdx, colOverscanEndIdx);\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n  var totalHeaderHeight = headerRowHeight + (enableFilters ? headerFiltersHeight : 0);\n  var clientHeight = height - 2 // border width\n  - totalHeaderHeight - (summaryRows?.length ?? 0) * rowHeight - (totalColumnWidth > viewportWidth ? getScrollbarSize() : 0);\n\n  var _getVerticalRangeToRe = getVerticalRangeToRender(clientHeight, rowHeight, scrollTop, rows.length),\n      _getVerticalRangeToRe2 = _slicedToArray(_getVerticalRangeToRe, 2),\n      rowOverscanStartIdx = _getVerticalRangeToRe2[0],\n      rowOverscanEndIdx = _getVerticalRangeToRe2[1];\n  /**\r\n   * effects\r\n   */\n\n\n  useLayoutEffect(function () {\n    // Do not calculate the width if width is provided\n    if (typeof width === 'number') return;\n\n    function onResize() {\n      // Immediately re-render when the component is mounted to get valid columnMetrics.\n      setGridWidth(gridRef.current.getBoundingClientRect().width);\n    }\n\n    onResize();\n    window.addEventListener('resize', onResize);\n    return function () {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [width]);\n  useEffect(function () {\n    if (!onSelectedRowsChange) return;\n\n    var handleRowSelectionChange = function handleRowSelectionChange(_ref2) {\n      var rowIdx = _ref2.rowIdx,\n          checked = _ref2.checked,\n          isShiftClick = _ref2.isShiftClick;\n      assertIsValidKey(rowKey);\n      var newSelectedRows = new Set(selectedRows);\n      var rowId = rows[rowIdx][rowKey];\n\n      if (checked) {\n        newSelectedRows.add(rowId);\n        var previousRowIdx = lastSelectedRowIdx.current;\n        lastSelectedRowIdx.current = rowIdx;\n\n        if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n          var step = Math.sign(rowIdx - previousRowIdx);\n\n          for (var i = previousRowIdx + step; i !== rowIdx; i += step) {\n            newSelectedRows.add(rows[i][rowKey]);\n          }\n        }\n      } else {\n        newSelectedRows.delete(rowId);\n        lastSelectedRowIdx.current = -1;\n      }\n\n      onSelectedRowsChange(newSelectedRows);\n    };\n\n    return eventBus.subscribe('SELECT_ROW', handleRowSelectionChange);\n  }, [eventBus, onSelectedRowsChange, rows, rowKey, selectedRows]);\n  useImperativeHandle(ref, function () {\n    return {\n      scrollToColumn: function scrollToColumn(idx) {\n        scrollToCell({\n          idx: idx\n        });\n      },\n      scrollToRow: function scrollToRow(rowIdx) {\n        var current = gridRef.current;\n        if (!current) return;\n        current.scrollTop = rowIdx * rowHeight;\n      },\n      selectCell: function selectCell(position, openEditor) {\n        eventBus.dispatch('SELECT_CELL', position, openEditor);\n      }\n    };\n  });\n  /**\r\n   * event handlers\r\n   */\n\n  function onGridScroll(event) {\n    var _event$currentTarget = event.currentTarget,\n        scrollTop = _event$currentTarget.scrollTop,\n        scrollLeft = _event$currentTarget.scrollLeft;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll?.(event);\n  }\n\n  var handleColumnResize = useCallback(function (column, width) {\n    var newColumnWidths = new Map(columnWidths);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n    onColumnResize?.(column.idx, width);\n  }, [columnWidths, onColumnResize]);\n\n  function handleRowsUpdate(event) {\n    onRowsUpdate?.(event);\n  }\n  /**\r\n   * utils\r\n   */\n\n\n  function getFrozenColumnsWidth() {\n    if (lastFrozenColumnIndex === -1) return 0;\n    var lastFrozenCol = columns[lastFrozenColumnIndex];\n    return lastFrozenCol.left + lastFrozenCol.width;\n  }\n\n  function scrollToCell(_ref3) {\n    var idx = _ref3.idx,\n        rowIdx = _ref3.rowIdx;\n    var current = gridRef.current;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      var clientWidth = current.clientWidth;\n      var _columns$idx = columns[idx],\n          left = _columns$idx.left,\n          _width = _columns$idx.width;\n      var isCellAtLeftBoundary = left < scrollLeft + _width + getFrozenColumnsWidth();\n      var isCellAtRightBoundary = left + _width > clientWidth + scrollLeft;\n\n      if (isCellAtLeftBoundary || isCellAtRightBoundary) {\n        var newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n        current.scrollLeft = scrollLeft + newScrollLeft;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        // at top boundary, scroll to the row's top\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        // at bottom boundary, scroll the next row's top to the bottom of the viewport\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getViewportRows() {\n    var rowElements = [];\n\n    for (var rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      var row = rows[rowIdx];\n      var key = rowIdx;\n      var isRowSelected = false;\n\n      if (rowKey !== undefined) {\n        var rowId = row[rowKey];\n        isRowSelected = selectedRows?.has(rowId) ?? false;\n\n        if (typeof rowId === 'string' || typeof rowId === 'number') {\n          key = rowId;\n        }\n      }\n\n      rowElements.push(React.createElement(RowRenderer, {\n        key: key,\n        rowIdx: rowIdx,\n        row: row,\n        viewportColumns: viewportColumns,\n        lastFrozenColumnIndex: lastFrozenColumnIndex,\n        eventBus: eventBus,\n        isRowSelected: isRowSelected,\n        onRowClick: onRowClick,\n        rowClass: rowClass,\n        top: rowIdx * rowHeight + totalHeaderHeight\n      }));\n    }\n\n    return rowElements;\n  }\n\n  return React.createElement(\"div\", {\n    className: \"rdg\",\n    style: {\n      width: width,\n      height: height,\n      '--header-row-height': \"\".concat(headerRowHeight, \"px\"),\n      '--filter-row-height': \"\".concat(headerFiltersHeight, \"px\"),\n      '--row-width': \"\".concat(totalColumnWidth, \"px\"),\n      '--row-height': \"\".concat(rowHeight, \"px\")\n    },\n    ref: gridRef,\n    onScroll: onGridScroll\n  }, React.createElement(HeaderRow, {\n    rowKey: rowKey,\n    rows: rows,\n    columns: viewportColumns,\n    onColumnResize: handleColumnResize,\n    lastFrozenColumnIndex: lastFrozenColumnIndex,\n    allRowsSelected: selectedRows?.size === rows.length,\n    onSelectedRowsChange: onSelectedRowsChange,\n    sortColumn: sortColumn,\n    sortDirection: sortDirection,\n    onSort: onSort\n  }), enableFilters && React.createElement(FilterRow, {\n    lastFrozenColumnIndex: lastFrozenColumnIndex,\n    columns: viewportColumns,\n    filters: filters,\n    onFiltersChange: onFiltersChange\n  }), rows.length === 0 && emptyRowsRenderer ? createElement(emptyRowsRenderer) : React.createElement(React.Fragment, null, viewportWidth > 0 && React.createElement(InteractionMasks, {\n    rows: rows,\n    rowHeight: rowHeight,\n    columns: columns,\n    enableCellAutoFocus: enableCellAutoFocus,\n    enableCellCopyPaste: enableCellCopyPaste,\n    enableCellDragAndDrop: enableCellDragAndDrop,\n    cellNavigationMode: cellNavigationMode,\n    eventBus: eventBus,\n    gridRef: gridRef,\n    totalHeaderHeight: totalHeaderHeight,\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop,\n    scrollToCell: scrollToCell,\n    editorPortalTarget: editorPortalTarget,\n    onCheckCellIsEditable: onCheckCellIsEditable,\n    onRowsUpdate: handleRowsUpdate,\n    onSelectedCellChange: onSelectedCellChange\n  }), React.createElement(\"div\", {\n    style: {\n      height: Math.max(rows.length * rowHeight, clientHeight)\n    }\n  }), getViewportRows(), summaryRows?.map(function (row, rowIdx) {\n    return React.createElement(SummaryRow, {\n      key: rowIdx,\n      rowIdx: rowIdx,\n      row: row,\n      bottom: rowHeight * (summaryRows.length - 1 - rowIdx),\n      viewportColumns: viewportColumns,\n      lastFrozenColumnIndex: lastFrozenColumnIndex\n    });\n  })));\n}\n\nexport default forwardRef(DataGrid);","map":null,"metadata":{},"sourceType":"module"}